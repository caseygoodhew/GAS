<script>

const ERROR = 'ERROR';
const WARN = 'WARN';
const OK = 'OK';

const SYMBOLS = 'SYMBOLS';
const SYMBOL_MAP = 'SYMBOL_MAP';

const setGlobalConfig = (name, values) => {
  document.globalConfig = document.globalConfig || {};
  document.globalConfig[name] = values;
}

const getGlobalConfig = (name) => {
  if (!document.globalConfig) {
    throw new Error(`globalConfig has not been initialized (getting ${name})`);
  }

  if (!document.globalConfig[name]) {
    throw new Error(`globalConfig[${name}] has not been initialized`);
  }

  return document.globalConfig[name];
}

const lastStoredData = (() => {

  let lsData = {};
  let lsValidations = {};
  
  const funcs = {
    update: (data, validations) => {
      lsData = data;
      lsValidations = validations || {};
    },

    getData: () => lsData,
    getValidations: () => lsValidations
  }

  return funcs;
})();

window.addEventListener('load', function() {
  [1, 2, 3, 4].forEach(secNum => {
    const initialValue = document.getElementById(`dateRangeMode${secNum}`).value;
    handleDateRangeModeChange(secNum, initialValue);
  });

  remoteCall({
    handler: api => api.getIOCInitializationData(),
    success: (data) => {
      const globals = data['globals'];
      setDatePickerLimits(globals.minDate, globals.maxDate);
      
      setAccountPickerOptions(data['getIOCFactorConfigs']['accounts']);
      storeSymbols(data['getIOCFactorConfigs']['symbols']);

      // lastly we load the last used data
      let storedConfig = data['getIOCCurrentConfiguration'];
      if (storedConfig) {
        loadData(storedConfig);
      } else {
        storedConfig = getData();
      }
      lastStoredData.update(storedConfig);
    },
    failure: 'Error loading initialization data',
    spinner: 'Getting initialization data'
  });

  addChangeListeners();
});

const addChangeListeners = () => {
  // Select all inputs and selects inside the setup container
  const fields = document.querySelectorAll('#setup input, #setup select');

  fields.forEach(field => {
    field.addEventListener('change', onAnyDataChange);
  });
};

const onAnyDataChange = debounce(() => {
  setActionsEnabled(!isEqual(getData(), lastStoredData.getData()));
});

const openTab = (evt, tabName) => {
  const contents = document.getElementsByClassName("tab-content");
  for (let i = 0; i < contents.length; i++) {
    contents[i].classList.remove("active");
  }
  
  const tabs = document.getElementsByClassName("tab");
  for (let i = 0; i < tabs.length; i++) {
    tabs[i].classList.remove("active");
  }

  document.getElementById(tabName).classList.add("active");
  evt.currentTarget.classList.add("active");
};

const toggleSection = (id) => {
  const element = document.getElementById(id);
  element.classList.toggle("expanded");
};

const handleDateRangeModeChange = (secNum, value) => {
  const startCont = document.getElementById(`startDateContainer${secNum}`);
  const endCont = document.getElementById(`endDateContainer${secNum}`);
  const dateSameAsCont = document.getElementById(`dateSameAsContainer${secNum}`);
  const datePeriodCont = document.getElementById(`datePeriodContainer${secNum}`);
  const taxYearCont = document.getElementById(`taxYearContainer${secNum}`);

  // Reset visibility
  startCont.classList.add('hidden');
  endCont.classList.add('hidden');
  dateSameAsCont.classList.add('hidden');
  datePeriodCont.classList.add('hidden');
  taxYearCont.classList.add('hidden');

  switch (value) {
    case 'current':
      datePeriodCont.classList.remove('hidden');
      break;
    case 'fixed-start':
      startCont.classList.remove('hidden');
      datePeriodCont.classList.remove('hidden');
      break;
    case 'fixed-end':
      endCont.classList.remove('hidden');
      datePeriodCont.classList.remove('hidden');
      break;
    case 'tax-year':
      taxYearCont.classList.remove('hidden');
      break;
      
    case 'same-as':
      dateSameAsCont.classList.remove('hidden');
      break;
    case 'custom':
      startCont.classList.remove('hidden');
      endCont.classList.remove('hidden');
      break;
  }
};

/**
 * Enables or disables the action buttons
 * @param {boolean} enabled - True to enable, false to disable
 */
const setActionsEnabled = (enabled) => {
  const saveBtn = document.getElementById('saveBtn');
  const discardBtn = document.getElementById('discardBtn');
  
  saveBtn.disabled = !enabled;
  discardBtn.disabled = !enabled;
};

const handleSave = () => {
  
  const data = getData();

  remoteCall({
    handler: api => api.setIOCCurrentConfiguration(data),
    spinner: 'Saving configuration',
    success: () => {
      lastStoredData.update(data);
      setActionsEnabled(false);
      clearAllValidation();
    },
    userError: (payload) => {
      
      refreshValidations(payload);

      if (payload.status !== ERROR) {
        lastStoredData.update(data, payload);
        setActionsEnabled(false);
      }
    },
    failure: `Error saving current configuration`
  });
  
};

const refreshValidations = payload => {
  clearAllValidation();

  if (!payload.results) {
    return;
  }
  
  let maxLevel = OK;
  const grouped = Object.values(payload.results.reduce((acc, item) => {
    acc[item.secNum] = acc[item.secNum] || { level: OK, secNum: item.secNum, results: [] };
    acc[item.secNum].results.push(item);

    if (acc[item.secNum].level === ERROR || item.level === ERROR) {
      acc[item.secNum].level = ERROR;
    } else if (acc[item.secNum].level === WARN || item.level === WARN) {
      acc[item.secNum].level = WARN;
    }

    if (maxLevel === ERROR || item.level === ERROR) {
      maxLevel = ERROR;
    } else if (maxLevel === WARN || item.level === WARN) {
      maxLevel = WARN;
    }

    return acc;
  }, { }));

  grouped.forEach(group => {
    setSectionValidation(group.secNum, group.level, ...group.results.map(x => x.message)) 
  });
//debugger;
  if (maxLevel === ERROR) {
    const statusTabIcon = document.getElementById(`setupTabIcon`);
    statusTabIcon.classList.add('error-indicator');
    statusTabIcon.classList.remove('hidden');
  }
};

const handleDiscard = () => {
  loadData(lastStoredData.getData());
  refreshValidations(lastStoredData.getValidations());
  setActionsEnabled(false);
};

const getFields = () => {
  return {
    bySection: {
      'dateRangeMode': {
        onLoad: (secNum, value) => {
          handleDateRangeModeChange(secNum, value);
        }
      },
      'startDate': {},
      'endDate': {},
      'offsetPeriod': {},
      'taxYear': {},
      'dateSameAs': {},
      'dataSetMode': {
        onLoad: (secNum, value) => {
          handleDataSetModeChange(secNum, value);
        }
      },
      'byPerformance': {},
      'performanceFilter': {},
      'dataSetSameAs': {}
    }, 
    byLine: {
      'dataSetLineMode': {
        onLoad: (secNum, lineNum, value) => {
          handleDataSetLineModeChange(secNum, lineNum, value);
        }
      },
      'account': {},
      'symbols': {
        onLoad: (secNum, lineNum, values) => {
          clearSymbolTags(secNum, lineNum);
          values.forEach(value => addSymbolTag(secNum, lineNum, value));
        },
        getValue: getSelectedSymbols
      },
    }
  };
}

const loadData = (data) => {
  const {bySection, byLine} = getFields();

  const sectionFields = Object.keys(bySection);
  const lineFields = Object.keys(byLine);

  [1, 2, 3, 4].forEach(secNum => {
    sectionFields.forEach(name => {
      const field = document.getElementById(`${name}${secNum}`);
      
      const value = data[secNum - 1][name];
      field.value = value;

      if (bySection[name].onLoad) {
        bySection[name].onLoad(secNum, value);
      }
    });

    [1, 2, 3, 4].forEach(lineNum => {
      lineFields.forEach(name => {
        const field = document.getElementById(`${name}${secNum}${lineNum}`);
      
        const value = data[secNum - 1].lines[lineNum - 1][name];
        field.value = value

        if (byLine[name].onLoad) {
          byLine[name].onLoad(secNum, lineNum, value);
        }
      });
    });  
  });
};

const getData = () => {
  const {bySection, byLine} = getFields();
  const sectionFields = Object.keys(bySection);
  const lineFields = Object.keys(byLine);

  const data = [1, 2, 3, 4].reduce((data, secNum) => {
    const section = sectionFields.reduce((item, name) => {
      
      const field = document.getElementById(`${name}${secNum}`);
      const value = (bySection[name].getValue) ? bySection[name].getValue(secNum) : field.value;
      
      return {
        ...item,
        [name]: value
      };

    }, {});

    const lines = [1, 2, 3, 4].reduce((lines, lineNum) => {
      const line = lineFields.reduce((item, name) => {
        
        const field = document.getElementById(`${name}${secNum}${lineNum}`);
        const value = (byLine[name].getValue) ? byLine[name].getValue(secNum, lineNum) : field.value;

        return {
          ...item,
          [name]: value
        };

      }, {});
      
      return [
        ...lines,
        line
      ];
    }, [])

    return [...data, { ...section, lines } ];
  }, []);

  return data;
}

/**
 * Updates the UI validation state for a specific section
 * @param {number} secNum - The section index (1-4)
 * @param {string|null} type - 'error', 'warning', or null to clear
 * @param {string} message - The text to display
 */
const setSectionValidation = (secNum, type, ...messages) => {
  const icon = document.getElementById(`statusIcon${secNum}`);
  const box = document.getElementById(`validationBox${secNum}`);
  const listElement = document.getElementById(`validationList${secNum}`);

  // Reset states
  icon.classList.remove('error', 'warn');
  icon.classList.add('hidden');

  box.classList.remove('error', 'warn');
  box.classList.add('hidden');
  
  listElement.innerHTML = ''; // Clear previous list items

  // Exit if clearing validation
  if (type === OK) {
    return;
  } 

  // Show Icon
  icon.classList.remove('hidden');
  icon.classList.add(type.toLowerCase());

  // Show Message Box
  box.classList.remove('hidden');
  box.classList.add(type.toLowerCase());
  
  let alreadyShown = [];
  messages.forEach(msg => {
    // there's circular ref checks that can be included twice - easiest just to dedupe at this level
    if (!alreadyShown.includes(msg)) {
      const li = document.createElement('li');
      li.innerText = msg;
      listElement.appendChild(li);
      alreadyShown.push(msg);
    }
  });
  
  // Optional: Auto-expand the section if there is an error
  if (type === ERROR) {
    document.getElementById(`sec${secNum}`).classList.add('expanded');
  }
};

/**
 * Clears all validation errors and warnings for all 4 sections
 */
const clearAllValidation = () => {
  const sections = [1, 2, 3, 4];
  
  sections.forEach(secNum => {
    // We pass OK to trigger your existing 'Reset states' logic 
    // and the early 'return' in setSectionValidation.
    setSectionValidation(secNum, OK);
  });

  const statusTabIcon = document.getElementById(`setupTabIcon`);
  statusTabIcon.classList.add('hidden');
  statusTabIcon.classList.remove('error-indicator');
};

const setDatePickerLimits = (minDate, maxDate) => {
  const datePickers = document.querySelectorAll('input[type="date"]');
  
  minDate = formatToYYYYMMDD(minDate);
  maxDate = formatToYYYYMMDD(maxDate);

  datePickers.forEach(picker => {
    picker.setAttribute('min', minDate);
    picker.setAttribute('max', maxDate);
  });
};

const storeSymbols = (symbols) => {
  setGlobalConfig(
    SYMBOL_MAP, 
    symbols
  );
  
  setGlobalConfig(
    SYMBOLS, 
    Object.keys(symbols).map(key => ({ key, value: symbols[key] }))
  );
}

const handleDataSetModeChange = (secNum, mode) => {
  const dataSetSameAsContainer = document.getElementById(`dataSetSameAsContainer${secNum}`);
  const byPerformanceContainer = document.getElementById(`byPerformanceContainer${secNum}`);

  const dataSetLineModeContainers = [1, 2, 3, 4].map(lineNum => ({
    pillContainer: document.getElementById(`definedLineContainer${secNum}${lineNum}`),
    container: document.getElementById(`dataSetLineModeContainer${secNum}${lineNum}`),
    field: document.getElementById(`dataSetLineMode${secNum}${lineNum}`),
    lineNum
  }));
  

  // Hide all by default, then selectively show
  dataSetSameAsContainer.classList.add('hidden');
  byPerformanceContainer.classList.add('hidden');
  
  dataSetLineModeContainers.forEach(({pillContainer, container, lineNum}) => {
    pillContainer.classList.add('hidden');
    container.classList.add('hidden');
    handleDataSetLineModeChange(secNum, lineNum);
  });

  if (mode === 'defined') {
    dataSetLineModeContainers.forEach(({pillContainer, container, field, lineNum}) => {
      pillContainer.classList.remove('hidden');
      container.classList.remove('hidden');
      handleDataSetLineModeChange(secNum, lineNum, field.value)
    });
  } else if (mode === 'performance') {
    byPerformanceContainer.classList.remove('hidden');
  } else if (mode === 'same-as') {
    dataSetSameAsContainer.classList.remove('hidden');
  }
};

/**
 * Switches visibility based on the chosen Data Set mode
 */
const handleDataSetLineModeChange = (secNum, lineNum, mode) => {
  
  const accContainer = document.getElementById(`accountContainer${secNum}${lineNum}`);
  const symContainer = document.getElementById(`symbolContainer${secNum}${lineNum}`);

  // Hide both by default, then selectively show
  accContainer.classList.add('hidden');
  symContainer.classList.add('hidden');

  if (mode === 'account') {
    accContainer.classList.remove('hidden');
  } else if (mode === 'holding') {
    symContainer.classList.remove('hidden');
  }
};

const setAccountPickerOptions = (accounts) => {
  const accountKeys = Object.keys(accounts);

  [1, 2, 3, 4].forEach(secNum => {
    [1, 2, 3, 4].forEach(lineNum => {
      const dropdown = document.getElementById(`account${secNum}${lineNum}`);
      const options = accountKeys.map(key => `<option value="${key}">${accounts[key]}</option>`);
      dropdown.innerHTML = options.join('');
    });

    const dropdown = document.getElementById(`performanceFilter${secNum}`);
    const options = [
      { key: 'none', value: 'None' }, 
      ...accountKeys.map(key => ({ key, value: accounts[key]}))
    ].map(
      ({key, value}) => `<option value="${key}">${value}</option>`
    );
    dropdown.innerHTML = options.join('');
  });
}

const populateSymbols = (secNum, lineNum) => {
  const existing = getSelectedSymbols(secNum, lineNum);
  
  const dropdown = document.getElementById(`symbolSearch${secNum}${lineNum}`);
  
  let options = ['<option value="">Select symbols...</option>'];
    
  const config = getGlobalConfig(SYMBOLS);
  
  config.forEach(({key, value}) => {
    if (!existing.includes(key)) {
      options.push(`<option value="${key}">${value}</option>`);
    }
  });
    
  dropdown.innerHTML = options.join('');
};

/**
 * Adds a visual tag for a selected symbol
 */
const addSymbolTag = (secNum, lineNum, symbol) => {
  if (!symbol) return;

  const existing = getSelectedSymbols(secNum, lineNum);
  
  if (existing.includes(symbol)) {
    return;
  }
  
  const wrapper = document.createElement('x');
  const symbolMap = getGlobalConfig(SYMBOL_MAP);
  
  wrapper.innerHTML = `
  <div class="tag">
    <span class="tag-text" data-value="${symbol}"">${symbolMap[symbol]}</span>
    <span class="tag-remove" onclick="removeTag(this)"></span>
  </div>
  `;

  document.getElementById(`symbols${secNum}${lineNum}`).appendChild(wrapper.children[0]);
  
  // Reset dropdown to "Select symbols..."
  document.getElementById(`symbolSearch${secNum}${lineNum}`).value = "";

  populateSymbols(secNum, lineNum);
  onAnyDataChange();
};

const getSelectedSymbols = (secNum, lineNum) => {
  if (secNum == null) {
    throw new Error(`Cannot getSelectedSymbols without providing a secNum`)
  }
  
  return Array.from(
    document
      .getElementById(`symbols${secNum}${lineNum}`)
      .querySelectorAll('.tag-text')
    ).map(span => span.dataset.value);
}

/**
 * Removes a tag and marks the form as dirty
 */
const removeTag = (element) => {
  element.parentElement.remove();
  onAnyDataChange();
};

const clearSymbolTags = (secNum, lineNum) => {
  Array.from(
    document
      .getElementById(`symbols${secNum}${lineNum}`)
      .querySelectorAll('.tag-remove')
  ).forEach(el => removeTag(el));
}

</script>
