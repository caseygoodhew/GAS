<script>

const ERROR = 'ERROR';
const WARN = 'WARN';
const OK = 'OK';

const lastStoredData = (() => {

  let lsData = {};
  let lsValidations = {};
  
  const funcs = {
    update: (data, validations) => {
      lsData = data;
      lsValidations = validations || {};
    },

    getData: () => lsData,
    getValidations: () => lsValidations
  }

  return funcs;
})();

window.addEventListener('load', function() {
  [1, 2, 3, 4].forEach(secNum => {
    const initialValue = document.getElementById(`dateRangeMode${secNum}`).value;
    handleDateRangeModeChange(secNum, initialValue);
  });

  remoteCall({
    handler: api => api.getIOCInitializationData(),
    success: (data) => {
      const globals = data['globals'];
      setDatePickerLimits(globals.minDate, globals.maxDate);
      
      applyFactorConfig(data['getIOCFactorConfigs'])

      // lastly we load the last used data
      loadData(data['getIOCCurrentConfiguration']);
      lastStoredData.update(data);
    },
    failure: 'Error loading initialization data',
    spinner: 'Getting initialization data'
  });

  addChangeListeners();
});

const addChangeListeners = () => {
  // Select all inputs and selects inside the setup container
  const fields = document.querySelectorAll('#setup input, #setup select');

  fields.forEach(field => {
    field.addEventListener('change', () => {
      setActionsEnabled(!isEqual(getData(), lastStoredData.getData()));
    });
  });
};

const openTab = (evt, tabName) => {
  const contents = document.getElementsByClassName("tab-content");
  for (let i = 0; i < contents.length; i++) {
    contents[i].classList.remove("active");
  }
  
  const tabs = document.getElementsByClassName("tab");
  for (let i = 0; i < tabs.length; i++) {
    tabs[i].classList.remove("active");
  }

  document.getElementById(tabName).classList.add("active");
  evt.currentTarget.classList.add("active");
};

const toggleSection = (id) => {
  const element = document.getElementById(id);
  element.classList.toggle("expanded");
};

const handleDateRangeModeChange = (secNum, value) => {
  const startCont = document.getElementById(`startDateContainer${secNum}`);
  const endCont = document.getElementById(`endDateContainer${secNum}`);
  const dateSameAsCont = document.getElementById(`dateSameAsContainer${secNum}`);
  const datePeriodCont = document.getElementById(`datePeriodContainer${secNum}`);
  const taxYearCont = document.getElementById(`taxYearContainer${secNum}`);

  // Reset visibility
  startCont.classList.add('hidden');
  endCont.classList.add('hidden');
  dateSameAsCont.classList.add('hidden');
  datePeriodCont.classList.add('hidden');
  taxYearCont.classList.add('hidden');

  switch (value) {
    case 'current':
      datePeriodCont.classList.remove('hidden');
      break;
    case 'fixed-start':
      startCont.classList.remove('hidden');
      datePeriodCont.classList.remove('hidden');
      break;
    case 'fixed-end':
      endCont.classList.remove('hidden');
      datePeriodCont.classList.remove('hidden');
      break;
    case 'tax-year':
      taxYearCont.classList.remove('hidden');
      break;
      
    case 'same-as':
      dateSameAsCont.classList.remove('hidden');
      break;
    case 'custom':
      startCont.classList.remove('hidden');
      endCont.classList.remove('hidden');
      break;
  }
};

/**
 * Enables or disables the action buttons
 * @param {boolean} enabled - True to enable, false to disable
 */
const setActionsEnabled = (enabled) => {
  const saveBtn = document.getElementById('saveBtn');
  const discardBtn = document.getElementById('discardBtn');
  
  saveBtn.disabled = !enabled;
  discardBtn.disabled = !enabled;
};

const handleSave = () => {
  
  const data = getData();

  remoteCall({
    handler: api => api.setIOCCurrentConfiguration(data),
    spinner: 'Saving configuration',
    success: () => {
      lastStoredData.update(data);
      setActionsEnabled(false);
      clearAllValidation();
    },
    userError: (payload) => {
      
      refreshValidations(payload);

      if (payload.status !== ERROR) {
        lastStoredData.update(data, payload);
        setActionsEnabled(false);
      }
    },
    failure: `Error saving current configuration`
  });
  
};

const refreshValidations = payload => {
  clearAllValidation();

  if (!payload.results) {
    return;
  }
      
  const grouped = Object.values(payload.results.reduce((acc, item) => {
    acc[item.secNum] = acc[item.secNum] || { level: OK, secNum: item.secNum, results: [] };
    acc[item.secNum].results.push(item);

    if (acc[item.secNum].level === ERROR || item.level === ERROR) {
      acc[item.secNum].level = ERROR;
    } else if (acc[item.secNum].level === WARN || item.level === WARN) {
      acc[item.secNum].level = WARN;
    }

    return acc;
  }, {}));

  grouped.forEach(group => {
    setSectionValidation(group.secNum, group.level, ...group.results.map(x => x.message)) 
  });
};

const handleDiscard = () => {
  loadData(lastStoredData.getData());
  refreshValidations(lastStoredData.getValidations());
  setActionsEnabled(false);
};

const getFields = () => {
  return {
    'dateRangeMode': {
      onLoad: (secNum, value) => {
        handleDateRangeModeChange(secNum, value);
      }
    },
    'startDate': {},
    'endDate': {},
    'offsetPeriod': {},
    'taxYear': {},
    'dateSameAs': {},
  };
}

const loadData = (data) => {
  const fields = getFields();
  const fieldNames = Object.keys(fields);

  for (let i = 1; i <= 4; i++) {
    fieldNames.forEach(name => {
      const field = document.getElementById(`${name}${i}`);
      field.value = data[i-1][name];

      if (fields[name].onLoad) {
        fields[name].onLoad(i, field.value);
      }
    });  
  }
};

const getData = () => {
  const fields = getFields();
  const fieldNames = Object.keys(fields);
  const data = [];

  for (let i = 1; i <= 4; i++) {
    data.push(fieldNames.reduce((item, name) => {
      const field = document.getElementById(`${name}${i}`);
      item[name] = field.value;
      return item;
    }, {}));  
  }

  return data;
}

/**
 * Updates the UI validation state for a specific section
 * @param {number} secNum - The section index (1-4)
 * @param {string|null} type - 'error', 'warning', or null to clear
 * @param {string} message - The text to display
 */
const setSectionValidation = (secNum, type, ...messages) => {
  const icon = document.getElementById(`statusIcon${secNum}`);
  const box = document.getElementById(`validationBox${secNum}`);
  const listElement = document.getElementById(`validationList${secNum}`);

  // Reset states
  icon.classList.remove('error', 'warn');
  icon.classList.add('hidden');

  box.classList.remove('error', 'warn');
  box.classList.add('hidden');
  
  listElement.innerHTML = ''; // Clear previous list items

  // Exit if clearing validation
  if (type === OK) {
    return;
  } 

  // Show Icon
  icon.classList.remove('hidden');
  icon.classList.add(type.toLowerCase());

  // Show Message Box
  box.classList.remove('hidden');
  box.classList.add(type.toLowerCase());
  
  let alreadyShown = [];
  messages.forEach(msg => {
    // there's circular ref checks that can be included twice - easiest just to dedupe at this level
    if (!alreadyShown.includes(msg)) {
      const li = document.createElement('li');
      li.innerText = msg;
      listElement.appendChild(li);
      alreadyShown.push(msg);
    }
  });
  
  // Optional: Auto-expand the section if there is an error
  if (type === ERROR) {
    document.getElementById(`sec${secNum}`).classList.add('expanded');
  }
};

/**
 * Clears all validation errors and warnings for all 4 sections
 */
const clearAllValidation = () => {
  const sections = [1, 2, 3, 4];
  
  sections.forEach(secNum => {
    // We pass OK to trigger your existing 'Reset states' logic 
    // and the early 'return' in setSectionValidation.
    setSectionValidation(secNum, OK);
  });
};

const setDatePickerLimits = (minDate, maxDate) => {
  const datePickers = document.querySelectorAll('input[type="date"]');
  
  minDate = formatToYYYYMMDD(minDate);
  maxDate = formatToYYYYMMDD(maxDate);

  datePickers.forEach(picker => {
    picker.setAttribute('min', minDate);
    picker.setAttribute('max', maxDate);
  });
};

const applyFactorConfig = (config) => {
  console.logJSON(config)
}

</script>
