<script>
const predictorMovementsModule = moduleWrapper({
  save: {
    handler: (api, data) => api.saveSetupData(data),
    success: (data) => {},
    userError: (payload) => {},
  }
}, ({ bus, constants, onDataChange }) => {

  const { REGISTRY } = constants;
  const RECURRENCE_LIST = ['One time only', 'Monthly', 'Quarterly', 'Yearly'];
  const appState = {};
  const SECTIONS = ['income', 'regular', 'mortgage', 'lifeEvents'];

  const clearAppState = () => {
    appState.movements = {};
    appState.accounts = {};

    SECTIONS.forEach(key => appState.movements[key] = []);
  }

  const setData = (data) => {
    clearAppState();

    if (data) {
      SECTIONS.forEach(key => {
        if (Array.isArray(data[key])) {
          appState.movements[key] = data[key];
        }
      });
    }

    refreshAccounts();
    renderAllMovementsSections();
  }

  const getData = () => {
    return clone(appState.movements);
  }

  const refreshAccounts = () => {
    const registryData = bus.relay(REGISTRY).getData();
    const ownersMap = (registryData.owners || []).reduce((acc, owner) => {
      acc[owner.id] = owner.name;
      return acc;
    }, {});

    // Filter out deleted entries and format labels as [Owner Name] - [Account Name]
    appState.accounts = (registryData.accounts || [])
      .filter(acc => !acc.isDeleted)
      .map(acc => ({
        id: acc.id,
        label: `${ownersMap[acc.ownerId] || 'Unknown'} - ${acc.name || 'Unnamed Account'}`
      }));
  }

  const calculateNewMortgageEntry = () => {
    let newItem;
    const mortgages = appState.movements.mortgage;
    const prev = mortgages.length > 0 ? mortgages[mortgages.length - 1] : null;

    if (prev) {
      const prevSummary = calculateMortgage(prev);
      const prevStart = new Date(prev.startDate);
      const prevEnd = new Date(prev.endDate);
      const durationMs = prevEnd.getTime() - prevStart.getTime();

      const newPrincipal = prevSummary.closing;
      const newStart = new Date(prevEnd);
      const newEnd = new Date(newStart.getTime() + durationMs);
      const newRate = prev.rate;
      const targetPayment = prevSummary.payment;

      // FIX: Search from 1 year UPWARDS to find the shortest term 
      // that doesn't exceed the previous monthly payment.
      let bestYears = 40; 
      if (newPrincipal > 0) {
        for (let y = 1; y <= 40; y++) {
          const p = calculateMonthlyPayment(newPrincipal, newRate, y);
          if (p <= targetPayment) {
            bestYears = y;
            break; 
          }
        }
      }

      newItem = {
        principal: parseFloat(newPrincipal.toFixed(2)),
        years: bestYears,
        rate: newRate,
        startDate: newStart.toISOString().split('T')[0],
        endDate: newEnd.toISOString().split('T')[0],
        lumpSums: []
      };
    } else {
      newItem = { principal: 0, years: 25, rate: 0, startDate: '', endDate: '', lumpSums: [] };
    }

    return newItem;
  }

  const addMovement = (sectionType) => {
    const key = sectionType === 'life-event' ? 'lifeEvents' : sectionType;
    let newItem;

    if (key === 'mortgage') {
      newItem = calculateNewMortgageEntry();
    } else {
      // Default for regular income/expenses
      newItem = { label: '', amount: 0, fromAccount: '', toAccount: '', startDate: '', endDate: '', recurrence: 'Monthly' };
    }
    
    appState.movements[key].push(newItem);
    renderAllMovementsSections();
    onDataChange();
  };

  const removeMovement = (key, index) => {
    appState.movements[key].splice(index, 1);
    renderAllMovementsSections();
    onDataChange();
  };

  const updateField = (key, index, field, value) => {
    appState.movements[key][index][field] = value;
    onDataChange();
  };

  const populateAccountSelect = (select) => {
    select.innerHTML = '<option value="">-- Select Account --</option>';
    appState.accounts.forEach(acc => {
      const opt = document.createElement('option');
      opt.value = acc.id;
      opt.textContent = acc.label;
      select.appendChild(opt);
    });
  };

  const renderMovementRow = (container, item, index, sectionKey) => {
    const clone = document.getElementById('tpl-movement-row').content.cloneNode(true);
    const row = clone.querySelector('.movement-item');

    const bind = (selector, field, evt = 'input') => {
      const el = row.querySelector(selector);
      el.value = item[field] || '';
      el[evt === 'input' ? 'oninput' : 'onchange'] = (e) => {
        item[field] = e.target.value;
        onDataChange();
      };
    };

    bind('.field-label', 'label');
    bind('.field-amount', 'amount');
    bind('.field-start', 'startDate');
    bind('.field-end', 'endDate');
    bind('.field-recurrence', 'recurrence', 'change');

    const fromAcc = row.querySelector('.field-from-account');
    const toAcc = row.querySelector('.field-to-account');
    const recSelect = row.querySelector('.field-recurrence');

    [fromAcc, toAcc].forEach(select => {
      select.innerHTML = '<option value="">-- Select Account --</option>';
      appState.accounts.forEach(acc => {
        const opt = document.createElement('option');
        opt.value = acc.id;
        opt.textContent = acc.label;
        select.appendChild(opt);
      });
    });

    RECURRENCE_LIST.forEach(r => {
      const opt = document.createElement('option');
      opt.value = opt.textContent = r;
      recSelect.appendChild(opt);
    });

    fromAcc.value = item.fromAccount || '';
    toAcc.value = item.toAccount || '';
    recSelect.value = item.recurrence || 'Monthly';

    fromAcc.onchange = (e) => { item.fromAccount = e.target.value; onDataChange(); };
    toAcc.onchange = (e) => { item.toAccount = e.target.value; onDataChange(); };

    row.querySelector('.field-delete').onclick = () => {
      appState.movements[sectionKey].splice(index, 1);
      renderAllMovementsSections();
      onDataChange();
    };

    container.appendChild(clone);
  };

  /**
   * Helper to calculate a standard amortization monthly payment
   */
  const calculateMonthlyPayment = (principal, annualRate, years) => {
    if (principal <= 0 || years <= 0) return 0;
    const monthlyRate = (parseFloat(annualRate) || 0) / 100 / 12;
    const totalMonths = years * 12;
    if (monthlyRate === 0) return principal / totalMonths;
    return (principal * monthlyRate) / (1 - Math.pow(1 + monthlyRate, -totalMonths));
  };

  /**
   * Calculates mortgage summary values.
   * Logic: Total Capital = Principal - Closing Balance.
   * Total Paid = Total Monthly Payments + Total Lump Sums.
   */
  const calculateMortgage = (item) => {
    const principal = parseFloat(item.principal) || 0;
    const annualRate = (parseFloat(item.rate) || 0) / 100;
    const years = parseFloat(item.years) || 0;
    const startDate = item.startDate ? new Date(item.startDate) : null;
    const endDate = item.endDate ? new Date(item.endDate) : null;

    if (!principal || !years || !startDate || !endDate || endDate <= startDate) {
      return { payment: 0, capital: 0, interest: 0, totalPaid: 0, closing: 0 };
    }

    const monthlyRate = annualRate / 12;
    const monthlyPayment = calculateMonthlyPayment(principal, item.rate, years);

    // Calculate duration in months
    const diffMonths = (endDate.getFullYear() - startDate.getFullYear()) * 12 + (endDate.getMonth() - startDate.getMonth());
    
    let currentBalance = principal;
    let totalInterest = 0;
    let totalLumpSums = 0;
    let totalMonthlyPayments = 0;

    for (let i = 0; i < diffMonths; i++) {
      if (currentBalance <= 0) break;

      const interestForMonth = currentBalance * monthlyRate;
      let capitalRepaid = monthlyPayment - interestForMonth;
      let actualPayment = monthlyPayment;

      // Handle final payment/overpayment
      if (currentBalance < capitalRepaid) {
        actualPayment = currentBalance + interestForMonth;
        capitalRepaid = currentBalance;
      }

      totalInterest += interestForMonth;
      totalMonthlyPayments += actualPayment;
      currentBalance -= capitalRepaid;

      // Check for Lump Sums in this month
      const currentMonthDate = new Date(startDate.getFullYear(), startDate.getMonth() + i, 1);
      const m = currentMonthDate.getMonth();
      const y = currentMonthDate.getFullYear();

      (item.lumpSums || []).forEach(ls => {
        if (ls.date && currentBalance > 0) {
          const lsDate = new Date(ls.date);
          if (lsDate.getMonth() === m && lsDate.getFullYear() === y) {
            let val = parseFloat(ls.amount) || 0;
            // Rule: <= 100 is %, > 100 is £
            let amount = val > 100 ? val : (currentBalance * (val / 100));
            if (amount > currentBalance) amount = currentBalance;
            
            totalLumpSums += amount;
            currentBalance -= amount;
          }
        }
      });
    }

    return {
      payment: monthlyPayment,
      capital: principal - Math.max(0, currentBalance),
      interest: totalInterest,
      totalPaid: totalMonthlyPayments + totalLumpSums,
      closing: Math.max(0, currentBalance)
    };
  };

  const renderMortgageRow = (container, item, index) => {
    const clone = document.getElementById('tpl-mortgage-row').content.cloneNode(true);
    const row = clone.querySelector('.mortgage-item');
    const dynamicContainer = row.querySelector('.mortgage-dynamic-rows');

    const updateUIValues = () => {
      const results = calculateMortgage(item);
      console.logJSON(results);
      const format = (val) => val.toLocaleString('en-GB', {minimumFractionDigits: 2, maximumFractionDigits: 2});
      
      row.querySelector('.field-summary-pay').textContent = `£${format(results.payment)}`;
      row.querySelector('.field-summary-cap').textContent = `£${format(results.capital)}`;
      row.querySelector('.field-summary-int').textContent = `£${format(results.interest)}`;
      row.querySelector('.field-summary-total').textContent = `£${format(results.totalPaid)}`;
      row.querySelector('.field-summary-close').textContent = `£${format(results.closing)}`;
    };

    const renderLumpSums = () => {
      dynamicContainer.innerHTML = '';
      
      (item.lumpSums || []).forEach((ls, lsIdx) => {
        const div = document.createElement('div');
        div.className = 'grid-mortgage-lump-row';
        
        // Date Input
        const dateInp = document.createElement('input');
        dateInp.type = 'date';
        dateInp.className = 'field-start'; // Reuse existing date styling
        dateInp.value = ls.date || '';
        dateInp.oninput = (e) => { ls.date = e.target.value; updateUIValues(); onDataChange(); };

        // Amount Input
        const amtInp = document.createElement('input');
        amtInp.type = 'number';
        amtInp.placeholder = 'Amt £ or %';
        amtInp.value = ls.amount || '';
        amtInp.oninput = (e) => { ls.amount = e.target.value; updateUIValues(); onDataChange(); };

        // Trash Can Delete Button
        const delBtn = document.createElement('button');
        delBtn.className = 'btn-icon';
        delBtn.title = 'Remove Lump Sum';
        delBtn.innerHTML = `
          <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="3 6 5 6 21 6"></polyline>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
          </svg>`;
        delBtn.onclick = () => {
          item.lumpSums.splice(lsIdx, 1);
          renderLumpSums();
          updateUIValues();
          onDataChange();
        };

        div.appendChild(dateInp);
        div.appendChild(amtInp);
        div.appendChild(delBtn);
        dynamicContainer.appendChild(div);
      });

      // Circular Plus Button
      const addBtn = document.createElement('button');
      addBtn.className = 'btn-add-lump';
      addBtn.title = 'Add Lump Sum';
      addBtn.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
          <line x1="12" y1="5" x2="12" y2="19"></line>
          <line x1="5" y1="12" x2="19" y2="12"></line>
        </svg>`;
      addBtn.onclick = () => {
        item.lumpSums.push({ date: '', amount: 0 });
        renderLumpSums();
      };
      dynamicContainer.appendChild(addBtn);
    };

    const bind = (selector, field) => {
      const el = row.querySelector(selector);
      el.value = item[field] || '';
      el.oninput = (e) => {
        item[field] = e.target.value;
        updateUIValues();
        onDataChange();
      };
    };

    bind('.field-principal', 'principal');
    bind('.field-years', 'years');
    bind('.field-rate', 'rate');
    bind('.field-start', 'startDate');
    bind('.field-end', 'endDate');

    renderLumpSums();
    updateUIValues();

    row.querySelector('.field-delete').onclick = () => {
      appState.movements.mortgage.splice(index, 1);
      renderAllMovementsSections();
      onDataChange();
    };

    container.appendChild(clone);
  };

  const renderIncomeRow = (container, item, index, sectionKey) => {
    const clone = document.getElementById('tpl-income-row').content.cloneNode(true);
    const row = clone.querySelector('.movement-item');

    // Reuse shared binding logic for label, amount, dates, recurrence
    bindField(row, item, '.field-label', 'label');
    bindField(row, item, '.field-amount', 'amount');
    bindField(row, item, '.field-start', 'startDate');
    bindField(row, item, '.field-end', 'endDate');
    bindField(row, item, '.field-recurrence', 'recurrence', 'change');


    // Populate and bind Destination Account only
    const toAcc = row.querySelector('.field-to-account');
    populateAccountSelect(toAcc);
    toAcc.value = item.toAccount || '';
    toAcc.onchange = (e) => { item.toAccount = e.target.value; onDataChange(); };

    // Recurrence list population
    const recSelect = row.querySelector('.field-recurrence');
    RECURRENCE_LIST.forEach(r => {
      const opt = document.createElement('option');
      opt.value = opt.textContent = r;
      recSelect.appendChild(opt);
    });
    recSelect.value = item.recurrence || 'Monthly';

    row.querySelector('.field-delete').onclick = () => removeMovement(sectionKey, index);
    container.appendChild(clone);
  };

  // Helper for consistent field binding
  const bindField = (row, item, selector, field, evt = 'input') => {
    const el = row.querySelector(selector);
    el.value = item[field] || '';
    el[evt === 'input' ? 'oninput' : 'onchange'] = (e) => {
      item[field] = e.target.value;
      onDataChange();
    };
  };

  const renderAllMovementsSections = () => {
    const mappings = [
      { key: 'income', container: 'section-income-list', renderer: renderIncomeRow },
      { key: 'regular', container: 'section-regular-list', renderer: renderMovementRow },
      { key: 'mortgage', container: 'section-mortgage-list', renderer: renderMortgageRow },
      { key: 'lifeEvents', container: 'section-life-event-list', renderer: renderMovementRow }
    ]

    mappings.forEach(map => {
      const container = document.getElementById(map.container);
      if (!container) return;
      container.innerHTML = '';
      
      const items = appState.movements[map.key] || [];
      if (!items || items.length === 0) {
        renderEmptyEntries(container);
      } else {
        items.forEach((item, idx) => map.renderer(container, item, idx, map.key));
      }
    });
  };

  const renderEmptyEntries = (container) => {
    container.innerHTML = '<p class="empty-msg">No entries added yet.</p>';
  };

  const activate = () => {
    refreshAccounts();
    renderAllMovementsSections();
  }

  return {
    activate,
    getData,
    setData,
    addMovement
  };
});
//# sourceURL=js_movements.js
</script>
