<script>
const predictorMovementsModule = moduleWrapper({
  save: {
    handler: (api, data) => api.saveSetupData(data),
    success: (data) => {},
    userError: (payload) => {},
  }
}, ({ bus, constants, onDataChange }) => {

  const { REGISTRY } = constants;
  const RECURRENCE_LIST = ['One time only', 'Monthly', 'Quarterly', 'Yearly'];
  const appState = {};
  const SECTIONS = ['income', 'regular', 'mortgage', 'lifeEvents'];

  const clearAppState = () => {
    appState.movements = {};
    appState.accounts = {};

    SECTIONS.forEach(key => appState.movements[key] = []);
  }

  const setData = (data) => {
    clearAppState();

    if (data) {
      SECTIONS.forEach(key => {
        if (Array.isArray(data[key])) {
          appState.movements[key] = data[key];
        }
      });
    }

    refreshAccounts();
    renderAllMovementsSections();
  }

  const getData = () => {
    return clone(appState.movements);
  }

  const refreshAccounts = () => {
    const registryData = bus.relay(REGISTRY).getData();
    const ownersMap = (registryData.owners || []).reduce((acc, owner) => {
      acc[owner.id] = owner.name;
      return acc;
    }, {});

    // Filter out deleted entries and format labels as [Owner Name] - [Account Name]
    appState.accounts = (registryData.accounts || [])
      .filter(acc => !acc.isDeleted)
      .map(acc => ({
        id: acc.id,
        label: `${ownersMap[acc.ownerId] || 'Unknown'} - ${acc.name || 'Unnamed Account'}`
      }));
  }

  const addMovement = (sectionType) => {
    const key = sectionType === 'life-event' ? 'lifeEvents' : sectionType;
    const newItem = key === 'mortgage' 
      ? { principal: 0, years: 10, rate: 0, startDate: '', endDate: '', lumpSums: {} }
      : { label: '', amount: 0, fromAccount: '', toAccount: '', startDate: '', endDate: '', recurrence: 'Monthly' };
    
    appState.movements[key].push(newItem);
    renderAllMovementsSections();
    onDataChange();
  };

  const removeMovement = (key, index) => {
    appState.movements[key].splice(index, 1);
    renderAllMovementsSections();
    onDataChange();
  };

  const updateField = (key, index, field, value) => {
    appState.movements[key][index][field] = value;
    onDataChange();
  };

  const populateAccountSelect = (select) => {
    select.innerHTML = '<option value="">-- Select Account --</option>';
    appState.accounts.forEach(acc => {
      const opt = document.createElement('option');
      opt.value = acc.id;
      opt.textContent = acc.label;
      select.appendChild(opt);
    });
  };

  const renderMovementRow = (container, item, index, sectionKey) => {
    const clone = document.getElementById('tpl-movement-row').content.cloneNode(true);
    const row = clone.querySelector('.movement-item');

    const bind = (selector, field, evt = 'input') => {
      const el = row.querySelector(selector);
      el.value = item[field] || '';
      el[evt === 'input' ? 'oninput' : 'onchange'] = (e) => {
        item[field] = e.target.value;
        onDataChange();
      };
    };

    bind('.field-label', 'label');
    bind('.field-amount', 'amount');
    bind('.field-start', 'startDate');
    bind('.field-end', 'endDate');
    bind('.field-recurrence', 'recurrence', 'change');

    const fromAcc = row.querySelector('.field-from-account');
    const toAcc = row.querySelector('.field-to-account');
    const recSelect = row.querySelector('.field-recurrence');

    [fromAcc, toAcc].forEach(select => {
      select.innerHTML = '<option value="">-- Select Account --</option>';
      appState.accounts.forEach(acc => {
        const opt = document.createElement('option');
        opt.value = acc.id;
        opt.textContent = acc.label;
        select.appendChild(opt);
      });
    });

    RECURRENCE_LIST.forEach(r => {
      const opt = document.createElement('option');
      opt.value = opt.textContent = r;
      recSelect.appendChild(opt);
    });

    fromAcc.value = item.fromAccount || '';
    toAcc.value = item.toAccount || '';
    recSelect.value = item.recurrence || 'Monthly';

    fromAcc.onchange = (e) => { item.fromAccount = e.target.value; onDataChange(); };
    toAcc.onchange = (e) => { item.toAccount = e.target.value; onDataChange(); };

    row.querySelector('.field-delete').onclick = () => {
      appState.movements[sectionKey].splice(index, 1);
      renderAllMovementsSections();
      onDataChange();
    };

    container.appendChild(clone);
  };

  const renderMortgageRow = (container, item, index) => {
    const clone = document.getElementById('tpl-mortgage-row').content.cloneNode(true);
    const row = clone.querySelector('.mortgage-item');
    const dynamicContainer = row.querySelector('.mortgage-dynamic-rows');

    const updateMortgageRows = () => {
      dynamicContainer.innerHTML = '';
      if (!item.startDate || !item.endDate) return;

      const start = new Date(item.startDate);
      const end = new Date(item.endDate);
      let current = new Date(start.getFullYear() + 1, start.getMonth(), 0);

      while (current <= end) {
        const year = current.getFullYear();
        const rowDiv = document.createElement('div');
        rowDiv.className = 'grid-mortgage-yearly';
        
        const dateLabel = document.createElement('span');
        dateLabel.className = 'year-label';
        dateLabel.textContent = `${current.toLocaleString('default', { month: 'short' })} ${year}`;

        const lumpInput = document.createElement('input');
        lumpInput.type = 'number';
        lumpInput.step = '0.01';
        lumpInput.placeholder = 'Lump Sum %/Â£';
        lumpInput.value = item.lumpSums[year] || '';
        lumpInput.oninput = (e) => {
          item.lumpSums[year] = e.target.value;
          onDataChange();
        };

        rowDiv.appendChild(dateLabel);
        rowDiv.appendChild(lumpInput);
        dynamicContainer.appendChild(rowDiv);
        current = new Date(year + 1, current.getMonth(), current.getDate());
      }
    };

    const bind = (selector, field) => {
      const el = row.querySelector(selector);
      el.value = item[field] || '';
      el.oninput = (e) => {
        item[field] = e.target.value;
        if (field === 'startDate' || field === 'endDate') updateMortgageRows();
        onDataChange();
      };
    };

    bind('.field-principal', 'principal');
    bind('.field-years', 'years');
    bind('.field-rate', 'rate');
    bind('.field-start', 'startDate');
    bind('.field-end', 'endDate');

    updateMortgageRows();

    row.querySelector('.field-delete').onclick = () => {
      appState.movements.mortgage.splice(index, 1);
      renderAllMovementsSections();
      onDataChange();
    };

    container.appendChild(clone);
  };

  const renderIncomeRow = (container, item, index, sectionKey) => {
    const clone = document.getElementById('tpl-income-row').content.cloneNode(true);
    const row = clone.querySelector('.movement-item');

    // Reuse shared binding logic for label, amount, dates, recurrence
    bindField(row, item, '.field-label', 'label');
    bindField(row, item, '.field-amount', 'amount');
    bindField(row, item, '.field-start', 'startDate');
    bindField(row, item, '.field-end', 'endDate');
    bindField(row, item, '.field-recurrence', 'recurrence', 'change');


    // Populate and bind Destination Account only
    const toAcc = row.querySelector('.field-to-account');
    populateAccountSelect(toAcc);
    toAcc.value = item.toAccount || '';
    toAcc.onchange = (e) => { item.toAccount = e.target.value; onDataChange(); };

    // Recurrence list population
    const recSelect = row.querySelector('.field-recurrence');
    RECURRENCE_LIST.forEach(r => {
      const opt = document.createElement('option');
      opt.value = opt.textContent = r;
      recSelect.appendChild(opt);
    });
    recSelect.value = item.recurrence || 'Monthly';

    row.querySelector('.field-delete').onclick = () => removeMovement(sectionKey, index);
    container.appendChild(clone);
  };

  // Helper for consistent field binding
  const bindField = (row, item, selector, field, evt = 'input') => {
    const el = row.querySelector(selector);
    el.value = item[field] || '';
    el[evt === 'input' ? 'oninput' : 'onchange'] = (e) => {
      item[field] = e.target.value;
      onDataChange();
    };
  };

  const renderAllMovementsSections = () => {
    const mappings = [
      { key: 'income', container: 'section-income-list', renderer: renderIncomeRow },
      { key: 'regular', container: 'section-regular-list', renderer: renderMovementRow },
      { key: 'mortgage', container: 'section-mortgage-list', renderer: renderMortgageRow },
      { key: 'lifeEvents', container: 'section-life-event-list', renderer: renderMovementRow }
    ]

    mappings.forEach(map => {
      const container = document.getElementById(map.container);
      if (!container) return;
      container.innerHTML = '';
      
      const items = appState.movements[map.key] || [];
      if (!items || items.length === 0) {
        renderEmptyEntries(container);
      } else {
        items.forEach((item, idx) => map.renderer(container, item, idx, map.key));
      }
    });
  };

  const renderEmptyEntries = (container) => {
    container.innerHTML = '<p class="empty-msg">No entries added yet.</p>';
  };

  const activate = () => {
    refreshAccounts();
    renderAllMovementsSections();
  }

  return {
    activate,
    getData,
    setData,
    addMovement
  };
});
//# sourceURL=js_movements.js
</script>
