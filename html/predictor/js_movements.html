<script>
const predictorMovementsModule = moduleWrapper({
  save: {
    handler: (api, data) => api.saveSetupData(data),
    success: (data) => {},
    userError: (payload) => {},
  }
}, ({ bus, constants, onDataChange }) => {

  const { REGISTRY } = constants;
  const RECURRENCE_LIST = ['One time only', 'Monthly', 'Quarterly', 'Yearly'];
  const appState = {};
  const SECTIONS = ['income', 'regular', 'mortgage', 'lifeEvents'];

  const clearAppState = () => {
    appState.movements = {};
    appState.accounts = {};

    SECTIONS.forEach(key => appState.movements[key] = []);
  }

  const setData = (data) => {
    clearAppState();

    if (data) {
      SECTIONS.forEach(key => {
        if (Array.isArray(data[key])) {
          appState.movements[key] = data[key];
        }
      });
    }

    refreshAccounts();
    renderAllMovementsSections();
  }

  const getData = () => {
    return clone(appState.movements);
  }

  const refreshAccounts = () => {
    const registryData = bus.relay(REGISTRY).getData();
    const ownersMap = (registryData.owners || []).reduce((acc, owner) => {
      acc[owner.id] = owner.name;
      return acc;
    }, {});

    // Filter out deleted entries and format labels as [Owner Name] - [Account Name]
    appState.accounts = (registryData.accounts || [])
      .filter(acc => !acc.isDeleted)
      .map(acc => ({
        id: acc.id,
        label: `${ownersMap[acc.ownerId] || 'Unknown'} - ${acc.name || 'Unnamed Account'}`
      }));
  }

  const calculateNewMortgageEntry = () => {
    let newItem;
    const mortgages = appState.movements.mortgage;
    const prev = mortgages.length > 0 ? mortgages[mortgages.length - 1] : null;

    if (prev) {
      const prevSummary = calculateMortgage(prev);
      const prevStart = new Date(prev.startDate);
      const prevEnd = new Date(prev.endDate);
      const durationMs = prevEnd.getTime() - prevStart.getTime();

      const newPrincipal = prevSummary.closing;
      const newStart = new Date(prevEnd);
      const newEnd = new Date(newStart.getTime() + durationMs);
      const newRate = prev.rate;
      const targetPayment = prevSummary.payment;

      // FIX: Search from 1 year UPWARDS to find the shortest term 
      // that doesn't exceed the previous monthly payment.
      let bestYears = 40; 
      if (newPrincipal > 0) {
        for (let y = 1; y <= 40; y++) {
          const p = calculateMonthlyPayment(newPrincipal, newRate, y);
          if (p <= targetPayment) {
            bestYears = y;
            break; 
          }
        }
      }

      newItem = {
        principal: parseFloat(newPrincipal.toFixed(2)),
        years: bestYears,
        rate: newRate,
        startDate: newStart.toISOString().split('T')[0],
        endDate: newEnd.toISOString().split('T')[0],
        lumpSums: []
      };
    } else {
      newItem = { principal: 0, years: 25, rate: 0, startDate: '', endDate: '', lumpSums: [] };
    }

    return newItem;
  }

  const addMovement = (sectionType) => {
    const key = sectionType === 'life-event' ? 'lifeEvents' : sectionType;
    let newItem;

    if (key === 'mortgage') {
      newItem = calculateNewMortgageEntry();
    } else {
      // Default for regular income/expenses
      newItem = { label: '', amount: 0, fromAccount: '', toAccount: '', startDate: '', endDate: '', recurrence: 'Monthly' };
    }
    
    appState.movements[key].push(newItem);
    renderAllMovementsSections();
    onDataChange();
  };

  const removeMovement = (key, index) => {
    appState.movements[key].splice(index, 1);
    renderAllMovementsSections();
    onDataChange();
  };

  const updateField = (key, index, field, value) => {
    appState.movements[key][index][field] = value;
    onDataChange();
  };

  const populateAccountSelect = (select) => {
    select.innerHTML = '<option value="">-- Select Account --</option>';
    appState.accounts.forEach(acc => {
      const opt = document.createElement('option');
      opt.value = acc.id;
      opt.textContent = acc.label;
      select.appendChild(opt);
    });
  };

  const renderMovementRow = (container, item, index, sectionKey) => {
    const clone = document.getElementById('tpl-movement-row').content.cloneNode(true);
    const row = clone.querySelector('.movement-item');

    const bind = (selector, field, evt = 'input') => {
      const el = row.querySelector(selector);
      el.value = item[field] || '';
      el[evt === 'input' ? 'oninput' : 'onchange'] = (e) => {
        item[field] = e.target.value;
        onDataChange();
      };
    };

    bind('.field-label', 'label');
    bind('.field-amount', 'amount');
    bind('.field-start', 'startDate');
    bind('.field-end', 'endDate');
    bind('.field-recurrence', 'recurrence', 'change');

    const fromAcc = row.querySelector('.field-from-account');
    const toAcc = row.querySelector('.field-to-account');
    const recSelect = row.querySelector('.field-recurrence');

    [fromAcc, toAcc].forEach(select => {
      select.innerHTML = '<option value="">-- Select Account --</option>';
      appState.accounts.forEach(acc => {
        const opt = document.createElement('option');
        opt.value = acc.id;
        opt.textContent = acc.label;
        select.appendChild(opt);
      });
    });

    RECURRENCE_LIST.forEach(r => {
      const opt = document.createElement('option');
      opt.value = opt.textContent = r;
      recSelect.appendChild(opt);
    });

    fromAcc.value = item.fromAccount || '';
    toAcc.value = item.toAccount || '';
    recSelect.value = item.recurrence || 'Monthly';

    fromAcc.onchange = (e) => { item.fromAccount = e.target.value; onDataChange(); };
    toAcc.onchange = (e) => { item.toAccount = e.target.value; onDataChange(); };

    row.querySelector('.field-delete').onclick = () => {
      appState.movements[sectionKey].splice(index, 1);
      renderAllMovementsSections();
      onDataChange();
    };

    container.appendChild(clone);
  };

  /**
   * Helper to calculate a standard amortization monthly payment
   */
  const calculateMonthlyPayment = (principal, annualRate, years) => {
    if (principal <= 0 || years <= 0) return 0;
    const monthlyRate = (parseFloat(annualRate) || 0) / 100 / 12;
    const totalMonths = years * 12;
    if (monthlyRate === 0) return principal / totalMonths;
    return (principal * monthlyRate) / (1 - Math.pow(1 + monthlyRate, -totalMonths));
  };

  /**
   * Calculates mortgage summary values.
   * Logic: Total Capital = Principal - Closing Balance.
   * Total Paid = Total Monthly Payments + Total Lump Sums.
   */
  const calculateMortgage = (item) => {
    const principal = parseFloat(item.principal) || 0;
    const annualRate = (parseFloat(item.rate) || 0) / 100;
    const years = parseFloat(item.years) || 0;
    const startDate = item.startDate ? new Date(item.startDate) : null;
    const endDate = item.endDate ? new Date(item.endDate) : null;

    if (!principal || !years || !startDate || !endDate || endDate <= startDate) {
      return { payment: 0, capital: 0, interest: 0, totalPaid: 0, closing: 0, balancesByDate: {} };
    }

    const monthlyRate = annualRate / 12;
    const monthlyPayment = calculateMonthlyPayment(principal, item.rate, years);

    const diffMonths = (endDate.getFullYear() - startDate.getFullYear()) * 12 + (endDate.getMonth() - startDate.getMonth());
    
    let currentBalance = principal;
    let totalInterest = 0;
    let totalLumpSums = 0;
    let totalMonthlyPayments = 0;
    
    // Track balances by "YYYY-M" key for the UI conversion display
    const balancesByDate = {};

    for (let i = 0; i < diffMonths; i++) {
      if (currentBalance <= 0) break;

      // Store the balance at the start of this month before payments are applied
      const currentMonthDate = new Date(startDate.getFullYear(), startDate.getMonth() + i, 1);
      const m = currentMonthDate.getMonth();
      const y = currentMonthDate.getFullYear();
      balancesByDate[`${y}-${m}`] = currentBalance;

      const interestForMonth = currentBalance * monthlyRate;
      let capitalRepaid = monthlyPayment - interestForMonth;
      let actualPayment = monthlyPayment;

      if (currentBalance < capitalRepaid) {
        actualPayment = currentBalance + interestForMonth;
        capitalRepaid = currentBalance;
      }

      totalInterest += interestForMonth;
      totalMonthlyPayments += actualPayment;
      currentBalance -= capitalRepaid;

      (item.lumpSums || []).forEach(ls => {
        if (ls.date && currentBalance > 0) {
          const lsDate = new Date(ls.date);
          if (lsDate.getMonth() === m && lsDate.getFullYear() === y) {
            let val = parseFloat(ls.amount) || 0;
            // Balance used here is the balance AFTER the monthly scheduled payment
            let amount = val > 100 ? val : (currentBalance * (val / 100));
            if (amount > currentBalance) amount = currentBalance;
            
            totalLumpSums += amount;
            currentBalance -= amount;
          }
        }
      });
    }

    return {
      payment: monthlyPayment,
      capital: principal - Math.max(0, currentBalance),
      interest: totalInterest,
      totalPaid: totalMonthlyPayments + totalLumpSums,
      closing: Math.max(0, currentBalance),
      balancesByDate: balancesByDate // Return the map for the renderer
    };
  };

  const renderMortgageRow = (container, item, index) => {
    const clone = document.getElementById('tpl-mortgage-row').content.cloneNode(true);
    const row = clone.querySelector('.mortgage-item');
    const dynamicContainer = row.querySelector('.mortgage-dynamic-rows');

    const formatReadOnly = (val) => 
      Math.round(val || 0).toLocaleString('en-GB');

    // Helper to update only the summary totals and the conversion text
    // without rebuilding the DOM.
    const updateDisplayOnly = () => {
      const results = calculateMortgage(item);
      
      row.querySelector('.field-summary-pay').textContent = `£${formatReadOnly(results.payment)}`;
      row.querySelector('.field-summary-cap').textContent = `£${formatReadOnly(results.capital)}`;
      row.querySelector('.field-summary-int').textContent = `£${formatReadOnly(results.interest)}`;
      row.querySelector('.field-summary-total').textContent = `£${formatReadOnly(results.totalPaid)}`;
      row.querySelector('.field-summary-close').textContent = `£${formatReadOnly(results.closing)}`;

      // Update every lump sum conversion label based on the new calculation
      const lumpRows = dynamicContainer.querySelectorAll('.grid-mortgage-lump-row');
      lumpRows.forEach((lumpRow, idx) => {
        const ls = item.lumpSums[idx];
        const convDiv = lumpRow.querySelector('.field-lump-converted');
        const unitSpan = lumpRow.querySelector('.unit-icon');
        
        const val = parseFloat(ls.amount) || 0;
        let currentBalance = parseFloat(item.principal) || 0;
        
        if (ls.date) {
          const d = new Date(ls.date);
          const key = `${d.getFullYear()}-${d.getMonth()}`;
          currentBalance = results.balancesByDate[key] || currentBalance;
        }

        unitSpan.textContent = val > 100 ? '£' : '%';

        if (val > 100) {
          const percent = currentBalance > 0 ? (val / currentBalance) * 100 : 0;
          convDiv.textContent = `${percent.toFixed(1)}%`;
        } else {
          const cash = currentBalance * (val / 100);
          convDiv.textContent = `£${formatReadOnly(cash)}`;
        }
      });
    };

    const renderLumpSums = () => {
      dynamicContainer.innerHTML = '';
      
      (item.lumpSums || []).forEach((ls, lsIdx) => {
        const div = document.createElement('div');
        div.className = 'grid-mortgage-lump-row';
        
        // Date Input - Only triggers display update, not a full re-render
        const dateInp = document.createElement('input');
        dateInp.type = 'date';
        dateInp.value = ls.date || '';
        dateInp.oninput = (e) => { 
          ls.date = e.target.value; 
          updateDisplayOnly(); 
          onDataChange(); 
        };

        const amtWrapper = document.createElement('div');
        amtWrapper.className = 'field-with-unit';
        const unitSpan = document.createElement('span');
        unitSpan.className = 'unit-icon';

        // Amount Input - Only triggers display update
        const amtInp = document.createElement('input');
        amtInp.type = 'number';
        amtInp.value = ls.amount || '';
        amtInp.oninput = (e) => { 
          ls.amount = e.target.value; 
          updateDisplayOnly(); 
          onDataChange(); 
        };

        const convDiv = document.createElement('div');
        convDiv.className = 'field-lump-converted readonly-field';

        const flexDiv = document.createElement('div');
        
        const delBtn = document.createElement('button');
        delBtn.className = 'btn-icon';
        delBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>`;
        delBtn.onclick = () => {
          item.lumpSums.splice(lsIdx, 1);
          renderLumpSums(); // Re-render required here because the list length changed
          onDataChange();
        };

        const btnWrap = document.createElement('div');
        btnWrap.className = 'acc-col-action';
        btnWrap.appendChild(delBtn);

        amtWrapper.appendChild(unitSpan);
        amtWrapper.appendChild(amtInp);
        div.appendChild(dateInp);
        div.appendChild(amtWrapper);
        div.appendChild(convDiv);
        div.appendChild(flexDiv);
        div.appendChild(btnWrap);
        dynamicContainer.appendChild(div);
      });

      const addBtn = document.createElement('button');
      addBtn.className = 'btn-add-lump';
      addBtn.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>`;
      addBtn.onclick = () => {
        if (!item.lumpSums) item.lumpSums = [];
        item.lumpSums.push({ date: '', amount: 0 });
        renderLumpSums(); // Re-render required here
      };
      dynamicContainer.appendChild(addBtn);
      
      // Initialize the labels for the first time
      updateDisplayOnly();
    };

    // Binding for consolidated top-row fields
    const bind = (selector, field, isNumeric = false) => {
      const el = row.querySelector(selector);
      el.value = (field === 'principal') 
        ? (parseFloat(item[field]) || 0).toLocaleString('en-GB') 
        : (item[field] || '');

      el.oninput = (e) => {
        let rawVal = e.target.value;
        if (field === 'principal') rawVal = rawVal.replace(/,/g, '');
        item[field] = isNumeric ? parseFloat(rawVal) : rawVal;
        updateDisplayOnly();
        onDataChange();
      };

      if (field === 'principal') {
        el.onblur = (e) => {
          const num = parseFloat(e.target.value.replace(/,/g, '')) || 0;
          e.target.value = num.toLocaleString('en-GB');
        };
      }
    };

    bind('.field-principal', 'principal', true);
    bind('.field-years', 'years', true);
    bind('.field-rate', 'rate', true);
    bind('.field-start', 'startDate');
    bind('.field-end', 'endDate');

    renderLumpSums();
    container.appendChild(clone);
  };

  const renderIncomeRow = (container, item, index, sectionKey) => {
    const clone = document.getElementById('tpl-income-row').content.cloneNode(true);
    const row = clone.querySelector('.movement-item');

    // Reuse shared binding logic for label, amount, dates, recurrence
    bindField(row, item, '.field-label', 'label');
    bindField(row, item, '.field-amount', 'amount');
    bindField(row, item, '.field-start', 'startDate');
    bindField(row, item, '.field-end', 'endDate');
    bindField(row, item, '.field-recurrence', 'recurrence', 'change');


    // Populate and bind Destination Account only
    const toAcc = row.querySelector('.field-to-account');
    populateAccountSelect(toAcc);
    toAcc.value = item.toAccount || '';
    toAcc.onchange = (e) => { item.toAccount = e.target.value; onDataChange(); };

    // Recurrence list population
    const recSelect = row.querySelector('.field-recurrence');
    RECURRENCE_LIST.forEach(r => {
      const opt = document.createElement('option');
      opt.value = opt.textContent = r;
      recSelect.appendChild(opt);
    });
    recSelect.value = item.recurrence || 'Monthly';

    row.querySelector('.field-delete').onclick = () => removeMovement(sectionKey, index);
    container.appendChild(clone);
  };

  // Helper for consistent field binding
  const bindField = (row, item, selector, field, evt = 'input') => {
    const el = row.querySelector(selector);
    el.value = item[field] || '';
    el[evt === 'input' ? 'oninput' : 'onchange'] = (e) => {
      item[field] = e.target.value;
      onDataChange();
    };
  };

  const renderAllMovementsSections = () => {
    const mappings = [
      { key: 'income', container: 'section-income-list', renderer: renderIncomeRow },
      { key: 'regular', container: 'section-regular-list', renderer: renderMovementRow },
      { key: 'mortgage', container: 'section-mortgage-list', renderer: renderMortgageRow },
      { key: 'lifeEvents', container: 'section-life-event-list', renderer: renderMovementRow }
    ]

    mappings.forEach(map => {
      const container = document.getElementById(map.container);
      if (!container) return;
      container.innerHTML = '';
      
      const items = appState.movements[map.key] || [];
      if (!items || items.length === 0) {
        renderEmptyEntries(container);
      } else {
        items.forEach((item, idx) => map.renderer(container, item, idx, map.key));
      }
    });
  };

  const renderEmptyEntries = (container) => {
    container.innerHTML = '<p class="empty-msg">No entries added yet.</p>';
  };

  const activate = () => {
    refreshAccounts();
    renderAllMovementsSections();
  }

  return {
    activate,
    getData,
    setData,
    addMovement
  };
});
//# sourceURL=js_movements.js
</script>
