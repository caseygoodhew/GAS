<script>
const predictorRegistryModule = (() => {
  
  const appState = {
    owners: [], // Now holds { id, name }
    accounts: [] // Holds { id, name, ownerId, currency, aer, isDeleted }
  };

  let draggedId = null;

  const generateId = () => {
    return Math.random().toString(36).substr(2, 9);
  };

  // --- Drag and Drop Handlers ---

  const handleDragStart = (e, id) => {
    draggedId = id;
    // Use a timeout to ensure the 'dragging' class is applied after the ghost image is created
    setTimeout(() => {
      const row = document.querySelector(`[data-id="${id}"]`);
      if (row) {
        row.classList.add('dragging');
      }
    }, 0);
    e.dataTransfer.effectAllowed = 'move';
  };

  const handleDragOver = (e, targetId) => {
    if (e.preventDefault) {
      e.preventDefault();
    }
    
    // If we are dragging over a different item, update the order in real-time
    if (draggedId !== null && draggedId !== targetId) {
      const fromIndex = appState.accounts.findIndex((a) => { return a.id === draggedId; });
      const toIndex = appState.accounts.findIndex((a) => { return a.id === targetId; });

      if (fromIndex !== -1 && toIndex !== -1) {
        const [movedItem] = appState.accounts.splice(fromIndex, 1);
        appState.accounts.splice(toIndex, 0, movedItem);
        renderAccounts(); // Re-render to show the new positions
      }
    }
    
    return false;
  };

  const handleDrop = (e) => {
    if (e.stopPropagation) {
      e.stopPropagation();
    }
    return false;
  };

  const handleDragEnd = (e) => {
    draggedId = null;
    renderAccounts(); // Final render to clean up classes
  };

  /**
   * Renders the list of account owners
   */
  const renderOwners = () => {
    const container = document.getElementById('owners-list');
    const template = document.getElementById('owner-row-template');
    const owners = appState.owners || [];

    if (!container || !template) {
      return;
    }
    
    container.innerHTML = '';

    if (owners.length === 0) {
      container.innerHTML = '<p class="empty-msg">No owners added yet.</p>';
      return;
    }

    owners.forEach((owner) => {
      const clone = template.content.cloneNode(true);
      const row = clone.querySelector('.list-item');
      
      row.querySelector('.owner-name').textContent = owner.name;
      row.querySelector('.btn-icon').onclick = () => {
        removeOwner(owner.id);
      };
      
      container.appendChild(clone);
    });
  };

  /**
   * Adds a new owner object to the state
   */
  const addOwner = () => {
    const input = document.getElementById('new-owner-name');
    const name = input.value.trim();
    
    if (!name) {
      return;
    }

    if (appState.owners.some(o => o.name.toLowerCase() === name.toLowerCase())) {
      showAlert("Duplicate Name", `${name} is already in the list.`);
      return;
    }

    appState.owners.push({
      id: generateId(),
      name: name
    });

    input.value = '';
    input.focus();
    
    renderOwners();
    renderAccounts();
  };

  /**
   * Removes an owner by ID if they are not linked to any active accounts
   */
  const removeOwner = (id) => {
    const owner = appState.owners.find(o => o.id === id);
    if (!owner) {
      return;
    }
    
    const isAssigned = appState.accounts.some(acc => acc.ownerId === id && !acc.isDeleted);

    if (isAssigned) {
      showAlert("Cannot Remove", `${owner.name} is currently assigned to an account and cannot be removed.`);
      return;
    }

    appState.owners = appState.owners.filter(o => o.id !== id);
    renderOwners();
    renderAccounts();
  };

  /**
   * Renders the account table
   */
  const renderAccounts = () => {
    const container = document.getElementById('accounts-list');
    const template = document.getElementById('account-row-template');
    const accounts = (appState.accounts || []).filter((acc) => { return !acc.isDeleted; });
    const owners = appState.owners || [];

    if (!container || !template) {
      return;
    }

    container.innerHTML = '';

    if (accounts.length === 0) {            
      container.innerHTML = '<p class="empty-msg">No accounts added. Click "+ Account" to begin.</p>';            
      return;            
    }

    accounts.forEach((acc) => {
      const clone = template.content.cloneNode(true);
      const row = clone.querySelector('.account-row');
      
      // Set ID for CSS selection during drag
      row.setAttribute('data-id', acc.id);
      
      // If this is the item currently being dragged, maintain the class across re-renders
      if (acc.id === draggedId) {
        row.classList.add('dragging');
      }

      // Drag and Drop Listeners
      row.ondragstart = (e) => { handleDragStart(e, acc.id); };
      row.ondragover = (e) => { handleDragOver(e, acc.id); };
      row.ondrop = (e) => { handleDrop(e); };
      row.ondragend = (e) => { handleDragEnd(e); };

      const ownerSelect = row.querySelector('.field-owner');
      owners.forEach((owner) => {
        const opt = document.createElement('option');
        opt.value = owner.id;
        opt.textContent = owner.name;
        if (acc.ownerId === owner.id) {
          opt.selected = true;
        }
        ownerSelect.appendChild(opt);
      });

      row.querySelector('.field-name').value = acc.name || '';
      row.querySelector('.field-currency').value = acc.currency || 'GBP';
      row.querySelector('.field-aer').value = acc.aer ?? 0;

      row.querySelector('.field-name').oninput = (e) => {
        updateAccountField(acc.id, 'name', e.target.value);
      };
      ownerSelect.onchange = (e) => {
        updateAccountField(acc.id, 'ownerId', e.target.value);
      };
      row.querySelector('.field-currency').onchange = (e) => {
        updateAccountField(acc.id, 'currency', e.target.value);
      };
      row.querySelector('.field-aer').oninput = (e) => {
        updateAccountField(acc.id, 'aer', e.target.value);
      };
      row.querySelector('.field-delete').onclick = () => {
        removeAccount(acc.id);
      };

      container.appendChild(clone);
    });
  };

  const addAccount = () => {
    const newAccount = {
      id: generateId(),
      name: '',
      ownerId: appState.owners[0]?.id || '',
      currency: 'GBP',
      aer: 0,
      isDeleted: false
    };
    appState.accounts.push(newAccount);
    renderAccounts();
  };

  const removeAccount = (id) => {
    const acc = appState.accounts.find(a => a.id === id);
    if (acc) {
      acc.isDeleted = true;
      renderAccounts();
    }
  };

  const updateAccountField = (id, field, value) => {
    const acc = appState.accounts.find(a => a.id === id);
    if (!acc) {
      return;
    }

    const val = (field === 'aer') ? parseFloat(value) || 0 : value;
    acc[field] = val;
  };

  const handleOwnerKeyPress = (e) => {
    if (e.key === 'Enter') {
      addOwner();
    }
  };

  const getData = () => {
    return JSON.parse(JSON.stringify({
      owners: [...appState.owners],
      accounts: appState.accounts 
    }));
  };

  return {
    init: ({ data }) => {
      if (data) {
        if (data.owners) {
          appState.owners = data.owners;
        }
        if (data.accounts) {
          appState.accounts = data.accounts;
        }
      }
      renderOwners();
      renderAccounts();
    },
    activate: () => {},
    getData,
    addAccount,
    handleOwnerKeyPress,
    addOwner
  };
})();
//# sourceURL=js_registry.js
</script>